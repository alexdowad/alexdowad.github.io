---
layout: post
title:  "A Toy Runge-Kutta Differential Equation Solver"
date:   2023-08-22
categories:
  - math
  - differential equations
stylesheets:
  - runge.css
---

<p>This post presents a simple, interactive <a href='https://en.wikipedia.org/wiki/Differential_equation'>differential equation</a> solution graphing tool based on the classic <a href='https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods'>Runge-Kutta method</a> (which is really an algorithm).</p>

<p>It graphs solutions to one 1<sup>st</sup>-order equation, one 2<sup>nd</sup>-order equation, or a system of two 1<sup>st</sup>-order equations. The right-hand side of the equation(s) must be entered using syntax similar to expressions in the C, Java, or JavaScript programming languages (<a href='#syntax'>syntax help</a>). Since the solution of a differential equation depends on starting conditions, you can set the range of starting conditions which should be graphed and the “time” value at which the starting conditions apply. The tool will draw one line for each set of starting conditions.</p>

<p>Hover over a solution line to see what starting conditions it is based on. Roll your mouse wheel to zoom in and out; hold down the middle mouse button to pan. On mobile, use one finger to pan and pinch with two fingers to zoom.</p>

<p><b>Click these buttons to see a variety of samples:</b> <button id='sample_Y'>y' = y</button> <button id='sample_cosY'>y' = cos(y)</button> <button id='sample_cosT'>y'' = cos(t)</button> <button id='sample_cosY_2'>y'' = cos(y)</button> <button id='sample_logistic'>y' = ay - by² <i>(the logistic equation)</i></button> <button id='sample_mathieu'>y'' = y(a - 2q cos(t)) <i>(Mathieu's equation)</i></button> <button id='sample_riccati'>y' = -y²t² + (2y / t) <i>(a Riccati equation)</i></button> <button id='sample_cauchy'>y'' = -(a / t)y' - (b / t²)y <i>(a Cauchy-Euler equation)</i></button> <button id='sample_meissner'>y'' = -y(α² + ω² sign(cos(t))) <i>(Meissner equation)</i></button> <button id='sample_predprey'>y' = y - (0.01yz), z' = -z + (0.02yz) <i>(a “predator-prey” system)</i></button></p>

<p>Try playing with the parameters for some of the samples; you can get pretty wild pictures!</p>

<hr>

<div id='view1' style='height: 35rem'></div>
<div id='view2' style='height: 35rem'></div>

<div id='typewrapper'>
	Graph solutions for:
	<select id='graphtype'>
		<option value='order1'>one first-order equation</option>
		<option value='order2' selected>one second-order equation</option>
		<option value='eqs2_order1'>a system of two first-order equations</option>
	</select>
</div>
<div class='expwrapper'>
	<label for='exp1' style="font-style: italic">y'' =</label> <input id='exp1' value='cos(y)'>
</div>
<div class='expwrapper eqs2only' style="display: none">
	<span style="font-style: italic">z' =</span> <input id='exp2' value='cos(z)'>
</div>
<div class='params'>
	Start time: <input id='starttime' type='number' value='-10'>
	End time: <input id='endtime' type='number' value='10'>
	Time step: <input id='timestep' type='number' value='0.02'>
	<span title="Starting values for variables are at this time">t₀:</span> <input id='t0' type='number' value='0'>

	<label for='starty1' class='rowstart'>Min y(0):</label> <input id='starty1' type='number' value='-3'>
	<label for='starty2'>Max y(0):</label> <input id='starty2' type='number' value='3'>
	# values to graph: <input id='nstarty' type='number' value='5' max='50'>

	<label for='startdy1' class='order2only rowstart'>Min y'(0):</label> <input id='startdy1' type='number' value='-3' class='order2only'>
	<label for='startdy2' class='order2only'>Max y'(0):</label> <input id='startdy2' type='number' value='3' class='order2only'>
	<span class='order2only'># values to graph:</span> <input id='nstartdy' type='number' value='5' max='50' class='order2only'>

	<label for='startz1' class='eqs2only rowstart' style="display: none">Min z(0):</label> <input id='startz1' type='number' value='-3' class='eqs2only' style="display: none">
	<label for='startz2' class='eqs2only' style="display: none">Max z(0):</label> <input id='startz2' type='number' value='3' class='eqs2only' style="display: none">
	<span class='eqs2only' style="display: none"># values to graph:</span> <input id='nstartz' type='number' value='5' max='50' class='eqs2only' style="display: none">

	<label for='graph1' class='eqs2only rowstart' style="display: none">Left graph:</label>
	<select id='graph1' class='eqs2only' style="display: none">
		<option value='z-y' selected>z vs y</option>
		<option value='y-t'>y vs t</option>
		<option value='dy-y'>y' vs y</option>
		<option value='z-t'>z vs t</option>
		<option value='dz-z'>z' vs z</option>
	</select>
	<label for='graph2' class='eqs2only' style="display: none">Right graph:</label>
	<select id='graph2' class='eqs2only' style="display: none">
		<option value='z-y'>z vs y</option>
		<option value='y-t' selected>y vs t</option>
		<option value='dy-y'>y' vs y</option>
		<option value='z-t'>z vs t</option>
		<option value='dz-z'>z' vs z</option>
	</select>
</div>

<script src='/assets/js/d3-array.js'></script>
<script src='/assets/js/d3-color.js'></script>
<script src='/assets/js/d3-interpolate.js'></script>
<script src='/assets/js/d3-scale.js'></script>
<script src='/assets/js/d3-selection.js'></script>
<script src='/assets/js/d3-format.js'></script>
<script src='/assets/js/d3-axis.js'></script>
<script src='/assets/js/d3-dispatch.js'></script>
<script src='/assets/js/d3-timer.js'></script>
<script src='/assets/js/d3-ease.js'></script>
<script src='/assets/js/d3-transition.js'></script>
<script>
	'use strict';

	const $id = document.getElementById.bind(document);
	const $class = document.getElementsByClassName.bind(document);
	Element.prototype.$class = Element.prototype.getElementsByClassName;
	Element.prototype.$class1 = function(cssClass) { return this.$class(cssClass)?.[0]; }
	Element.prototype.listen = Element.prototype.addEventListener;

	// When getting min/max of a large array, this is far faster than using Math.min(...array)
	// and Math.max(...array), at least with V8 JS engine
	// Plus, we can also filter out NaN and Infinity
	function minMax(array) {
		let i = 1, limit = array.length, max = array[0], min = array[0];
		if (!Number.isFinite(max) || Number.isNaN(max)) {
			while (i < limit) {
				let value = array[i];
				if (Number.isFinite(value) && !Number.isNaN(value)) {
					min = max = value;
					break;
				}
				i++;
			}
		}
		while (i < limit) {
			let value = array[i];
			if (Number.isFinite(value) && !Number.isNaN(value)) {
				min = Math.min(min, value); // Hopefully this JITs to a single MINSD instruction on x86-64
				max = Math.max(max, value);
			}
			i++;
		}
		return [min, max];
	}

	function makeSvgNode(tag, cssClass, attributes = {}) {
		const node = document.createElementNS("http://www.w3.org/2000/svg", tag);
		if (cssClass)
			node.classList.add(cssClass);
		for (const [key, value] of Object.entries(attributes))
			node.setAttribute(key, value);
		return node;
	}

	function appendSvgNode(parent, tag, cssClass, attributes = {}) {
		const node = makeSvgNode(tag, cssClass, attributes);
		parent.appendChild(node);
		return node;
	}

	function prependSvgNode(parent, tag, cssClass, attributes = {}) {
		const node = makeSvgNode(tag, cssClass, attributes);
		parent.prepend(node);
		return node;
	}

	// Make SVG which will resize itself to match its container
	function initDynamicSvg(wrapper) {
		const svg = appendSvgNode(wrapper, 'svg', undefined, { viewBox: '0 0 200 200', preserveAspectRatio: 'none' });
		const watcher = new ResizeObserver(entries => {
			svg.style.width = Math.round(entries[0].contentBoxSize[0].inlineSize);
			svg.style.height = Math.round(entries[0].contentBoxSize[0].blockSize);
		});
		watcher.observe(wrapper);
		svg.style.width = wrapper.offsetWidth;
		svg.style.height = wrapper.offsetHeight;
		return svg;
	}

	// Convert position of a mouse event from px coordinates to SVG unit coordinates
	function getMousePosition(event, svg) {
		const CTM = svg.getScreenCTM();
		if (event.touches)
			event = event.touches[0];
		return [
			(event.clientX - CTM.e) / CTM.a,
			(event.clientY - CTM.f) / CTM.d
		];
	}

	function fireEvent(node, eventType) {
		node.dispatchEvent(new Event(eventType));
	}

	// Parser for C/Java/JavaScript-like expression syntax
	function tokenize(str) {
		str = str.replaceAll(/\s+/g, ''); // strip all whitespace
		str = str.replaceAll("\u{2212}", '-') // convert Unicode MINUS to ordinary dash
		if (!str.length)
			return [];
		str = str.toLowerCase();
		// Use 'sticky' regex so that matches must be contiguous; we don't just want to pick
		// matches out of the string, but want to split the entire string into matches
		const matches = Array.from(str.matchAll(/\d+(\.\d+)?|[()^/+-]|\*\*?|[\w'π]+/gy));
		const lastMatch = matches.at(-1);
		const matchedUpTo = lastMatch.index + lastMatch[0].length;
		if (matchedUpTo !== str.length) {
			// The last match did not appear at the end of the string, meaning there was
			// some text which we couldn't tokenize
			return [false, { offset: matchedUpTo, length: 1, message: "I don't know what to do with the highlighted character." }];
		}
		return [true, Array.from(matches).map((m) => m[0])]
	}

	const knownFunctions = new Set(['sqrt', 'sin', 'cos', 'tan', 'arcsin', 'arccos', 'arctan', 'ln', 'log', 'log10', 'log2', 'sgn', 'sign']);

	function parse(tokens) {
		const origTokens = Array.from(tokens); // Keep a copy for later inspection
		let exp;
		try {
			exp = parseExpression(tokens);
		} catch (e) {
			const match = e.message.match(/^Parse error: (.*)$/)
			if (match) {
				let lastTokenIndex = Math.max(0, origTokens.length-tokens.length-1);
				const precedingLength = origTokens.slice(0, lastTokenIndex).reduce((sum, s) => sum + s.length, 0);
				return [false, { offset: precedingLength, length: origTokens[lastTokenIndex].length, message: match[1] }]
			}
			throw e; // Not a parse error
		}
		if (tokens.length) {
			// All tokens should have been consumed by the parser
			const entireLength = origTokens.reduce((sum, s) => sum + s.length, 0);
			const remainingLength = tokens.reduce((sum, s) => sum + s.length, 0);
			return [false, { offset: entireLength - remainingLength, length: remainingLength, message: "The last part of this expression is extraneous; it doesn't seem like it should be there" }];
		}
		return [true, exp];
	}

	function parseExpression(tokens) {
		if (!tokens.length)
			throw new Error("Parse error: The expression is incomplete, you still need to add something more");

		let exp = parseNonBinaryExpression(tokens);

		if (!tokens.length)
			return exp;

		// Are we in the middle of a binary expression?
		const operands = [exp], operators = [];
		let tok = tokens[0];
		while (tok === '+' || tok === '-' || tok === '*' || tok === '/' || tok === '**' || tok === '^') {
			tokens.shift();
			operators.push(tok);
			operands.push(parseNonBinaryExpression(tokens));
			tok = tokens[0];
		}
		if (operators.length) {
			const operatorPriority = [new Set(['**', '^']), new Set(['*', '/']), new Set(['+', '-'])];
			for (const toCollapse of operatorPriority) {
				let i = 0;
				while (i < operators.length) {
					if (toCollapse.has(operators[i])) {
						operands[i] = [operators[i], operands[i], operands[i+1]];
						operands.splice(i+1, 1);
						operators.splice(i, 1);
					} else {
						i++;
					}
				}
			}
			if (operands.length !== 1)
				throw new Error("Parser could not properly build parse tree for binary operations");
			return operands[0];
		}
		return exp;
	}

	function parseNonBinaryExpression(tokens) {
		if (!tokens.length)
			throw new Error("Parse error: The expression is incomplete, you still need to add something more");
		const tok = tokens.shift();
		let subExp, nextTok;

		if (tok === '(') {
			subExp = parseExpression(tokens);
			nextTok = tokens.shift();
			if (nextTok !== ')') {
				throw new Error("Parse error: There should have been a closing parenthesis here");
			}
			return subExp;
		}

		if (tok === ')' || tok === '+' || tok === '*' || tok === '/' || tok === '**' || tok === '^')
			throw new Error("Parse error: I don't know what to do with the highlighted symbol in this position");

		if (/^\-?\d+(\.\d+)?$/.test(tok) || tok === 't' || tok === 'x' || tok === 'y' || tok === 'z' || tok === "y'" || tok == 'e' || tok === 'π' || tok === 'pi')
			return tok;

		if (tok === '-')
			return ['-', parseNonBinaryExpression(tokens)];

		if (/[\w']+/.test(tok)) {
			if (!knownFunctions.has(tok))
				throw new Error(`Parse error: I don't know what '${tok}' means`);
			nextTok = tokens.shift();
			if (nextTok !== '(')
				throw new Error(`Parse error: After the function '${tok}', there should be an opening parenthesis before the parameter`);
			let param = parseExpression(tokens);
			nextTok = tokens.shift();
			if (nextTok !== ')')
				throw new Error("Parse error: There should be a closing parenthesis after the function parameter");
			return [tok, param];
		}

		throw new Error(`Unexpected token: ${tok}`);
	}

	// Convert parsed expression to a JS function object
	function compileFunction(ast) {
		return new Function('t', 'y', 'z', `return ${compileNode(ast)};`);
	}

	function compileNode(ast) {
		if (ast === 't' || ast === 'y' || ast === 'z' || (typeof(ast) === 'string' && /^\-?\d+(\.\d+)?$/.test(ast)))
			return ast;
		if (ast === "y'")
			return 'z';
		// Both 't' and 'x' are traditional names for the independent variable; accept either
		if (ast === 'x')
			return 't';
		if (ast === 'e')
			return 'Math.E';
		if (ast === 'π' || ast === 'pi')
			return 'Math.PI';
		if (Array.isArray(ast)) {
			const fn = ast[0];
			if (fn === 'cos' || fn === 'sin' || fn === 'tan' || fn === 'sqrt' || fn === 'log2' || fn === 'log10')
				return `Math.${fn}(${compileNode(ast[1])})`;
			if (fn === 'arcsin' || fn === 'arccos' || fn === 'arctan')
				return `Math.a${fn.substr(3,3)}(${compileNode(ast[1])})`;
			if (fn === 'ln' || fn === 'log')
				return `Math.log(${compileNode(ast[1])})`
			if (fn === 'sgn' || fn === 'sign')
				return `Math.sign(${compileNode(ast[1])})`
			if (fn === '-' && ast.length === 2) {
				if (typeof(ast[1]) === 'string')
					return `-${compileNode(ast[1])}`;
				else
					return `-(${compileNode(ast[1])})`;
			}
			if (fn === '+' || fn === '-' || fn === '*' || fn === '/' || fn === '**')
				return `(${compileNode(ast[1])}) ${fn} (${compileNode(ast[2])})`;
			if (fn === '^')
				return `(${compileNode(ast[1])}) ** (${compileNode(ast[2])})`;
		}
		throw new Error(`Unexpected AST node: ${JSON.stringify(ast)}`);
	}

	function highlightParseError(input, error) {
		const inputStyles = getComputedStyle(input);
		const textMeasurer = document.createElement('span');
		textMeasurer.style.visibility = 'hidden';
		textMeasurer.style.font = inputStyles.font;
		document.body.appendChild(textMeasurer);

		const xOffset = input.offsetLeft + parseInt(inputStyles.borderLeftWidth) + parseInt(inputStyles.paddingLeft);
		textMeasurer.innerText = input.value.slice(0, error.offset);
		const left = textMeasurer.offsetWidth + xOffset;
		textMeasurer.innerText = input.value.slice(0, error.offset + error.length);
		const right = textMeasurer.offsetWidth + xOffset;
		const bottom = parseInt(inputStyles.borderBottomWidth);

		const underline = document.createElement('span');
		underline.classList.add('underline')
		underline.style.left = left + 'px';
		underline.style.width = (right - left) + 'px';
		underline.style.bottom = bottom + 'px';
		input.parentNode.appendChild(underline);

		if (error.message)
			input.setAttribute('title', error.message);

		textMeasurer.remove();
	}

	function clearParseError(input) {
		input.setAttribute('title', '');
		for (const underline of input.parentNode.$class('underline'))
			underline.remove();
	}

	class Solution {
		constructor(t_start, t_end, Δt, nVars) {
			this.t_start = t_start;
			this.t_end = t_end;
			this.Δt = Δt;
			this.nVars = nVars;
			this.nPoints = Math.floor(((t_end - t_start) / Δt) + 1);
			// Packed array of values for all variables at each time step:
			// (Values for each variable occupy a contiguous range of indices)
			this.array = new Float64Array(nVars * this.nPoints);
			// Packed array of estimated derivatives of all variables at each time step:
			this.diff = undefined;
		}

		// Find range of indices with values for a particular variable
		startIndex(varIndex) {
			return this.nPoints * varIndex;
		}
		endIndex(varIndex) {
			return this.startIndex(varIndex+1);
		}

		// Find index of value for a particular variable and time step
		timeIndex(varIndex, t) {
			return this.startIndex(varIndex) + Math.floor((t - this.t_start) / this.Δt);
		}
		timeValue(varIndex, t) {
			return this.array[this.timeIndex(varIndex, t)];
		}

		values(varIndex) {
			return this.array.subarray(this.startIndex(varIndex), this.endIndex(varIndex));
		}
	}

	class PhaseLine {
		constructor(solution, varIndexX = 0, varIndexY = 1) {
			this.solution = solution;
			this.varIndexX = varIndexX;
			this.varIndexY = varIndexY;
			this._bounds = undefined;
		}

		title() {
			return this.solution.startConditions;
		}

		svgPath(xScale, yScale) {
			const limit = this.solution.endIndex(this.varIndexX), ary = this.solution.array;
			const minXDiff = Math.abs(xScale.invert(0.01) - xScale.invert(0)), minYDiff = Math.abs(yScale.invert(0.01) - yScale.invert(0));
			let s = '', startingLine = true, prevX, prevY;
			for (let i = this.solution.startIndex(this.varIndexX), j = this.solution.startIndex(this.varIndexY); i < limit; i++, j++) {
				const x = ary[i], y = ary[j];
				if (Number.isNaN(x) || !Number.isFinite(x) || Number.isNaN(y) || !Number.isFinite(y) || Math.abs(x) > 1000000000000 || Math.abs(y) > 1000000000000) {
					startingLine = true;
				} else if (startingLine || Math.abs(x - prevX) >= minXDiff || Math.abs(y - prevY) >= minYDiff) {
					s += (startingLine ? 'M' : 'L') + xScale(x).toFixed(2) + ',' + yScale(y).toFixed(2);
					prevX = x;
					prevY = y;
					startingLine = false;
				}
			}
			return s;
		}

		bounds() {
			if (this._bounds)
				return this._bounds;
			const y_values = this.solution.values(0);
			const z_values = this.solution.values(1);
			return this._bounds = minMax(y_values).concat(minMax(z_values));
		}
	}

	// Graph the value of a variable against its derivative
	class DerivativeLine {
		constructor(solution, varIndex = 0, fn) {
			this.solution = solution;
			this.varIndex = varIndex;
			this._bounds = undefined;

			this.derivValues = new Float64Array(solution.endIndex(0));
			let t = solution.t_start;
			if (solution.nVars === 1) {
				const values = solution.values(varIndex);
				for (let i = 0; i < this.derivValues.length; i++) {
					this.derivValues[i] = fn(t, values[i]);
					t += solution.Δt;
				}
			} else if (solution.nVars === 2) {
				const yValues = solution.values(0), zValues = solution.values(1);
				for (let i = 0; i < this.derivValues.length; i++) {
					this.derivValues[i] = fn(t, yValues[i], zValues[i]);
					t += solution.Δt;
				}
			}
		}

		title() {
			return this.solution.startConditions;
		}

		svgPath(xScale, yScale) {
			const values = this.solution.values(this.varIndex), limit = this.solution.endIndex(0);
			const minXDiff = Math.abs(xScale.invert(0.01) - xScale.invert(0)), minYDiff = Math.abs(yScale.invert(0.01) - yScale.invert(0));
			let s = '', startingLine = true, prevX, prevY;
			for (let i = 0; i < limit; i++) {
				const x = values[i], y = this.derivValues[i];
				if (Number.isNaN(x) || !Number.isFinite(x) || Number.isNaN(y) || !Number.isFinite(y) || Math.abs(x) > 1000000000000 || Math.abs(y) > 1000000000000) {
					startingLine = true;
				} else if (startingLine || Math.abs(x - prevX) >= minXDiff || Math.abs(y - prevY) >= minYDiff) {
					s += (startingLine ? 'M' : 'L') + xScale(x).toFixed(2) + ',' + yScale(y).toFixed(2);
					prevX = x;
					prevY = y;
					startingLine = false;
				}
			}
			return s;
		}

		bounds() {
			if (this._bounds)
				return this._bounds;
			const values = this.solution.values(this.varIndex);
			return this._bounds = minMax(values).concat(minMax(this.derivValues));
		}
	}

	class TimeLine {
		constructor(solution, varIndex = 0) {
			this.solution = solution;
			this.varIndex = varIndex;
			this._bounds = undefined;
		}

		title() {
			return this.solution.startConditions;
		}

		svgPath(xScale, yScale) {
			const limit = this.solution.endIndex(this.varIndex), Δt = this.solution.Δt, ary = this.solution.array;
			let s = '', t = this.solution.t_start, startingLine = true;
			for (let i = this.solution.startIndex(this.varIndex); i < limit; i++) {
				const val = ary[i];
				if (!Number.isNaN(val) && Number.isFinite(val) && Math.abs(val) <= 1000000000000) {
					s += (startingLine ? 'M' : 'L') + xScale(t).toFixed(2) + ',' + yScale(val).toFixed(2);
					startingLine = false;
				} else {
					startingLine = true;
				}
				t += Δt;
			}
			return s;
		}

		bounds() {
			if (this._bounds)
				return this._bounds;
			const values = this.solution.values(this.varIndex);
			return this._bounds = [this.solution.t_start, this.solution.t_end].concat(minMax(values));
		}
	}

	function combinedBounds(lines) {
		const allBounds = lines.map((line) => line.bounds()).filter((bounds) => bounds.every((b) => !Number.isNaN(b) && Number.isFinite(b)));
		return [
			Math.min(...allBounds.map((b) => b[0])),
			Math.max(...allBounds.map((b) => b[1])),
			Math.min(...allBounds.map((b) => b[2])),
			Math.max(...allBounds.map((b) => b[3]))
		];
	}

	// Trace out evolution of our system using classic Runge-Kutta (AKA "RK4")
	// Store results in a packed array of floats
	function rk4trace(y, t, Δt, fn, ary, i, Δi, limit) {
		while (i !== limit) {
			const half_Δt = Δt / 2.0;
			const next_t = t + Δt;
			const half_t = t + half_Δt;

			const k_1 = fn(t, y); // Slope at starting point
			const k_2 = fn(half_t, y + (half_Δt * k_1)); // Estimated slope at mid-point
			const k_3 = fn(half_t, y + (half_Δt * k_2)); // Another estimate of slope at mid-point
			const k_4 = fn(next_t, y + (Δt * k_3)); // Estimated slope at endpoint

			const slope = (k_1 + 2*k_2 + 2*k_3 + k_4) / 6.0; // Weighted average of those four slopes

			y += Δt * slope;
			ary[i] = y;
			t += Δt;
			i += Δi;
		}
	}

	// Apply RK4 to find phase lines for a system with one dependent variable
	function rk4solve(y_0, t_0, t_start, t_end, Δt, fn) {
		let t = t_0, y = y_0, solution = new Solution(t_start, t_end, Δt, 1);
		let i = solution.timeIndex(0, t_0);
		solution.array[i] = y_0;

		// Trace out phase line from starting point
		rk4trace(y_0, t_0, Δt, fn, solution.array, i+1, 1, solution.endIndex(0));

		// Trace out phase line in the opposite direction from the starting point
		rk4trace(y_0, t_0, -Δt, fn, solution.array, i-1, -1, solution.startIndex(0)-1);

		return solution;
	}

	function rk4trace_2(y, z, t, Δt, fn_y, fn_z, ary, i, Δi, offset, limit) {
		while (i !== limit) {
			const half_Δt = Δt / 2.0;
			const next_t = t + Δt;
			const half_t = t + half_Δt;

			const k_1y = fn_y(t, y, z); // Slope at starting point
			const k_1z = fn_z(t, y, z);
			const k_2y = fn_y(half_t, y + (half_Δt * k_1y), z + (half_Δt * k_1z)); // Estimated slope at mid-point
			const k_2z = fn_z(half_t, y + (half_Δt * k_1y), z + (half_Δt * k_1z));
			const k_3y = fn_y(half_t, y + (half_Δt * k_2y), z + (half_Δt * k_2z)); // Another estimate of slope at mid-point
			const k_3z = fn_z(half_t, y + (half_Δt * k_2y), z + (half_Δt * k_2z));
			const k_4y = fn_y(next_t, y + (Δt * k_3y), z + (Δt * k_3z)); // Estimated slope at endpoint
			const k_4z = fn_z(next_t, y + (Δt * k_3y), z + (Δt * k_3z));

			const slope_y = (k_1y + 2*k_2y + 2*k_3y + k_4y) / 6.0; // Weighted average of those four slopes
			const slope_z = (k_1z + 2*k_2z + 2*k_3z + k_4z) / 6.0;

			y += Δt * slope_y;
			z += Δt * slope_z;
			ary[i] = y;
			ary[i+offset] = z;
			t += Δt;
			i += Δi;
		}
	}

	// Apply RK4 to find phase lines for a system with two dependent variables
	function rk4solve_2(y_0, z_0, t_0, t_start, t_end, Δt, fn_y, fn_z) {
		let t = t_0, y = y_0, z = z_0, solution = new Solution(t_start, t_end, Δt, 2);
		let i = solution.timeIndex(0, t_0), offset = solution.startIndex(1);
		solution.array[i] = y_0;
		solution.array[i+offset] = z_0;

		// Trace out phase line from starting point
		rk4trace_2(y_0, z_0, t_0, Δt, fn_y, fn_z, solution.array, i+1, 1, offset, solution.endIndex(0));

		// Trace out phase line in the opposite direction from the starting point
		rk4trace_2(y_0, z_0, t_0, -Δt, fn_y, fn_z, solution.array, i-1, -1, offset, solution.startIndex(0)-1);

		return solution;
	}

	function order1_solutions(y_0, t_0, t_start, t_end, Δt, fn) {
		const result = [];
		if (!Array.isArray(y_0))
			y_0 = [y_0];
		for (const y of y_0) {
			const solution = rk4solve(y, t_0, t_start, t_end, Δt, fn);
			solution.startConditions = `y(${t_0}) = ${y}`;
			solution.startY = y;
			result.push(solution);
		}
		return result;
	}

	function order2_solutions(y_0, dy_0, t_0, t_start, t_end, Δt, fn) {
		const result = [];
		if (!Array.isArray(y_0))
			y_0 = [y_0];
		if (!Array.isArray(dy_0))
			dy_0 = [dy_0];
		for (const y of y_0) {
			for (const dy of dy_0) {
				const solution = rk4solve_2(y, dy, t_0, t_start, t_end, Δt, function(t, y, dy) { return dy; }, fn);
				solution.startConditions = `y(${t_0}) = ${y}, y'(${t_0}) = ${dy}`;
				solution.startY = y;
				solution.startZ = dy;
				result.push(solution);
			}
		}
		return result;
	}

	function eqs2_order1_solutions(y_0, z_0, t_0, t_start, t_end, Δt, fn_y, fn_z) {
		const result = [];
		if (!Array.isArray(y_0))
			y_0 = [y_0];
		if (!Array.isArray(z_0))
			z_0 = [z_0];
		for (const y of y_0) {
			for (const z of z_0) {
				const solution = rk4solve_2(y, z, t_0, t_start, t_end, Δt, fn_y, fn_z);
				solution.startConditions = `y(${t_0}) = ${y}, z(${t_0}) = ${z}`;
				solution.startY = y;
				solution.startZ = z;
				result.push(solution);
			}
		}
		return result;
	}

	function gradations(from, to, n) {
		if (n === 0)
			return [];
		if (to == from)
			return [to];
		if (n === 1)
			return [(to - from) / 2];
		const result = [], interval = (to - from) / (n - 1);
		let value = from;
		n--;
		while (n--) {
			result.push(value);
			value += interval;
		}
		result.push(to);
		return result;
	}

	class Viewport {
		constructor(div, titles) {
			this.svg = initDynamicSvg(div);
			this.svg.classList.add('viewport');

			this.lines = []; this.colors = [];
			this.xAxis = this.yAxis = undefined; // DOM objects for axes
			this.xScale = this.yScale = undefined; // Scale objects used to draw graph
			this.xDomain = this.yDomain = undefined; // Currently displayed range of X/Y coordinates
			this.drawn = false;
			this.panning = false;
			this.touchPos = new Map;
			this.linkedViews = [];

			if (titles)
				this.setTitles(titles[0], titles[1]);

			this.svg.listen('wheel', this.mouseWheel.bind(this));
			this.svg.listen('mousedown', this.mouseDown.bind(this));
			this.svg.listen('mouseup', this.mouseUp.bind(this));
			this.svg.listen('mousemove', this.mouseMove.bind(this));
			this.svg.listen('mouseleave', this.mouseLeave.bind(this));
			this.svg.listen('touchstart', this.touchStart.bind(this));
			this.svg.listen('touchmove', this.touchMove.bind(this));
			this.svg.listen('touchend', this.touchEnd.bind(this));
			this.svg.listen('touchcancel', this.touchEnd.bind(this));
		}

		draw(lines, colors) {
			for (const path of Array.from(this.svg.$class('line')))
				path.remove();

			const bounds = combinedBounds(lines);
			const xSize = bounds[1] - bounds[0];
			const ySize = bounds[3] - bounds[2];
			// Don't allow the X/Y domain of the graph to become so large that exponential notation is used
			const xDomain = [Math.max(bounds[0] - (xSize * 0.05), -1000000000000), Math.min(bounds[1] + (xSize * 0.05), 1000000000000)];
			const yDomain = [Math.max(bounds[2] - (ySize * 0.05), -1000000000000), Math.min(bounds[3] + (ySize * 0.05), 1000000000000)];

			const xScale = d3.scaleLinear().domain(xDomain).range([25, 190]);
			const yScale = d3.scaleLinear().domain(yDomain).range([185, 15]);
			const xAxis = d3.axisBottom().scale(xScale);
			const yAxis = d3.axisLeft().scale(yScale);

			if (!this.xAxis) {
				this.xAxis = d3.select(this.svg).append('g').attr('class', 'axis xaxis').attr('transform', 'translate(0,185)').call(xAxis);
			} else {
				this.xAxis.transition().duration(250).call(xAxis);
			}
			if (!this.yAxis) {
				this.yAxis = d3.select(this.svg).append('g').attr('class', 'axis yaxis').attr('transform', 'translate(25,0)').call(yAxis);
			} else {
				this.yAxis.transition().duration(250).call(yAxis);
			}

			for (let i = 0; i < lines.length; i++) {
				const line = lines[i];
				const node = prependSvgNode(this.svg, 'path', 'line', {
					d: line.svgPath(xScale, yScale),
					stroke: colors[i],
					fill: 'none',
					'stroke-width': '.12rem',
					'vector-effect': 'non-scaling-stroke'
				});
				node.listen('mouseenter', () => this.linkedViews.forEach((view) => {
					view.highlightLine(i);
					node.setAttribute('stroke-width', '.24rem');
				}));
				node.listen('mouseleave', () => this.linkedViews.forEach((view) => {
					view.clearHighlight();
					node.setAttribute('stroke-width', '.12rem');
				}));
				if (line.title()) {
					const title = appendSvgNode(node, 'title');
					title.textContent = line.title();
				}
			}

			this.xScale = xScale; this.yScale = yScale; // Record scale which graph was first drawn at
			this.xDomain = xDomain; this.yDomain = yDomain;
			this.lines = Object.freeze(lines); this.colors = Object.freeze(colors);
			this.drawn = true;
		}

		adjustView(xDomain, yDomain, duration = 250) {
			if (!this.drawn)
				return;

			// Don't allow scale to become so large that exponential notation is used for axis labels
			xDomain = [Math.max(xDomain[0], -1000000000000), Math.min(xDomain[1], 1000000000000)];
			yDomain = [Math.max(yDomain[0], -1000000000000), Math.min(yDomain[1], 1000000000000)];

			const xScale = d3.scaleLinear().domain(xDomain).range([25, 190]);
			const yScale = d3.scaleLinear().domain(yDomain).range([185, 15]);
			const xAxis = d3.axisBottom().scale(xScale);
			const yAxis = d3.axisLeft().scale(yScale);

			this.xAxis.transition().duration(duration).call(xAxis);
			this.yAxis.transition().duration(duration).call(yAxis);

			const stretchX = (xScale(1) - xScale(0)) / (this.xScale(1) - this.xScale(0));
			const stretchY = (yScale(1) - yScale(0)) / (this.yScale(1) - this.yScale(0));

			d3.select(this.svg).selectAll('.line').transition().duration(duration)
				.attr('transform', `matrix(${stretchX} 0 0 ${stretchY} ${xScale(0) - (this.xScale(0) * stretchX)} ${yScale(0) - (this.yScale(0) * stretchY)})`);

			this.xDomain = xDomain; this.yDomain = yDomain;
		}

		// factor > 1 means zooming out, 0 < factor < 1 means zooming in
		zoom(factor) {
			if (factor <= 0)
				throw new Error("Cannot zoom by negative factor");
			const xSize = this.xDomain[1] - this.xDomain[0];
			const ySize = this.yDomain[1] - this.yDomain[0];
			const newXSize = xSize * factor;
			const newYSize = ySize * factor;
			const Δx = (newXSize - xSize) / 2;
			const Δy = (newYSize - ySize) / 2;
			this.adjustView([this.xDomain[0] - Δx, this.xDomain[1] + Δx], [this.yDomain[0] - Δy, this.yDomain[1] + Δy]);
		}

		pan(Δx, Δy, duration = 250) {
			if (Δx === 0 && Δy === 0)
				return;
			this.adjustView([this.xDomain[0] + Δx, this.xDomain[1] + Δx], [this.yDomain[0] + Δy, this.yDomain[1] + Δy], duration);
		}

		// Get position of mouse event in function input/output space
		mouseDomainPosition(event) {
			const pos = getMousePosition(event, this.svg);
			const xScale = d3.scaleLinear().domain(this.xDomain).range([25, 190]);
			const yScale = d3.scaleLinear().domain(this.yDomain).range([185, 15]);
			return [xScale.invert(pos[0]), yScale.invert(pos[1])];
		}

		mouseWheel(event) {
			event.preventDefault();
			if (!this.drawn)
				return;
			const [x, y] = this.mouseDomainPosition(event);
			const factor = Math.E ** (event.deltaY * 0.001);

			function scaleAround(v_0, v_1, factor) {
				return v_0 + ((v_1 - v_0) * factor);
			}

			// 100ms delay feels better than 250ms here
			this.adjustView([scaleAround(x, this.xDomain[0], factor), scaleAround(x, this.xDomain[1], factor)], [scaleAround(y, this.yDomain[0], factor), scaleAround(y, this.yDomain[1], factor)], 100);
		}

		mouseDown(event) {
			if (!this.drawn)
				return;
			if (event.button === 1 && !this.panning) {
				// middle/wheel button pressed
				this.beginPan(event);
			}
		}

		mouseUp(event) {
			if (this.panning) {
				this.endPan(event);
			}
		}

		mouseMove(event) {
			if (this.panning) {
				const panPos = this.mouseDomainPosition(event);
				this.pan(this.panStart[0] - panPos[0], this.panStart[1] - panPos[1], 0);
			}
		}

		mouseLeave(event) {
			if (this.panning) {
				this.endPan(event);
			}
		}

		beginPan(event) {
			this.panning = true;
			this.svg.classList.add('panning');
			this.panStart = this.mouseDomainPosition(event);
		}

		endPan(event) {
			this.panning = false;
			this.svg.classList.remove('panning');
			this.panStart = undefined;
		}

		touchStart(event) {
			this.touchPos.clear();
			for (const touch of event.targetTouches) {
				this.touchPos.set(touch.identifier, this.mouseDomainPosition(touch));
			}
		}

		touchMove(event) {
			if (this.touchPos.size === 1) {
				event.preventDefault();
				const touch = event.changedTouches[0];
				const startPos = this.touchPos.get(touch.identifier);
				if (!startPos)
					return;
				const currentPos = this.mouseDomainPosition(touch);
				this.pan(startPos[0] - currentPos[0], startPos[1] - currentPos[1], 0);
			} else if (this.touchPos.size === 2) {
				// Pinch to zoom (on mobile)
				event.preventDefault();

				function average(numbers) {
					return numbers.reduce((a,b) => a + b, 0) / numbers.length;
				}
				function avgPoint(points) {
					return [average(points.map((p) => p[0])), average(points.map((p) => p[1]))];
				}
				function distance(points) {
					return Math.sqrt((points[0][0] - points[1][0]) ** 2 + (points[0][1] - points[1][1]) ** 2);
				}

				const startPoints = Array.from(this.touchPos.values());
				const currentPoints = Array.from(event.targetTouches).map((t) => this.mouseDomainPosition(t));
				const startCenter = avgPoint(startPoints);
				const currentCenter = avgPoint(currentPoints);
				const Δx = startCenter[0] - currentCenter[0];
				const Δy = startCenter[1] - currentCenter[1];
				const stretch = distance(startPoints) / distance(currentPoints);

				function scaleAround(v_0, v_1, factor) {
					return v_0 + ((v_1 - v_0) * factor);
				}

				this.adjustView([scaleAround(startCenter[0], this.xDomain[0] + Δx, stretch), scaleAround(startCenter[0], this.xDomain[1] + Δx, stretch)], [scaleAround(startCenter[1], this.yDomain[0] + Δy, stretch), scaleAround(startCenter[1], this.yDomain[1] + Δy, stretch)], 0);
			}
		}

		touchEnd(event) {
			for (const touch of event.changedTouches) {
				this.touchPos.delete(touch.identifier);
			}
		}

		highlightLine(index) {
			this.clearHighlight();
			const line = this.lines[index];
			if (line) {
				const xScale = d3.scaleLinear().domain(this.xDomain).range([25, 190]);
				const yScale = d3.scaleLinear().domain(this.yDomain).range([185, 15]);
				const node = appendSvgNode(this.svg, 'path', 'line', {
					d: line.svgPath(xScale, yScale),
					stroke: this.colors[index],
					fill: 'none',
					'stroke-width': '.24rem',
					'vector-effect': 'non-scaling-stroke'
				});
				node.classList.add('highlight');
			}
		}

		clearHighlight() {
			for (const path of Array.from(this.svg.$class('highlight')))
				path.remove();
		}

		setTitles(xLabel, yLabel) {
			const xText = this.svg.$class1('xaxis-label');
			if (xText)
				xText.textContent = xLabel;
			else
				d3.select(this.svg).append('text').attr('class', 'xaxis-label').attr('transform', 'translate(193,190)').attr('font-size', '8').style('text-anchor', 'left').text(xLabel);
			const yText = this.svg.$class1('yaxis-label');
			if (yText)
				yText.textContent = yLabel;
			else
				d3.select(this.svg).append('text').attr('class', 'yaxis-label').attr('transform', 'translate(20,12)').attr('font-size', '8').style('text-anchor', 'left').text(yLabel);
		}
	}

	const vp1 = new Viewport($id('view1'), ['y', "y'"]);
	const vp2 = new Viewport($id('view2'), ['t', 'y']);
	vp1.linkedViews.push(vp2);
	vp2.linkedViews.push(vp1);

	const axisTitles = { 'z-y': ['y', 'z'], 'dy-y': ['y', "y'"], 'y-t': ['t', 'y'], 'dz-z': ['z', "z'"], 'z-t': ['t', 'z'] };

	function validateField(ok, good, field, message) {
		if (good) {
			field.setAttribute('title', '');
			field.classList.remove('err');
		} else {
			field.setAttribute('title', message);
			field.classList.add('err');
		}
		return ok && good;
	}

	function validate() {
		let ok = true;

		const timeStep = Number($id('timestep').value);
		const startTime = Number($id('starttime').value);
		const endTime = Number($id('endtime').value);
		const t0 = Number($id('t0').value);

		ok = validateField(ok, timeStep > 0, $id('timestep'), "Time step must be a positive number");
		ok = validateField(ok, startTime < endTime, $id('starttime'), "Start time must be before end time");
		ok = validateField(ok, startTime < endTime, $id('endtime'), "End time must be after start time");
		ok = validateField(ok, t0 >= startTime && t0 <= endTime, $id('t0'), "t₀ must be between start and end time");

		const min_y0 = Number($id('starty1').value);
		const max_y0 = Number($id('starty2').value);
		const n_y0 = Number($id('nstarty').value);

		ok = validateField(ok, min_y0 <= max_y0, $id('starty1'), "Min y must not be greater than max y");
		ok = validateField(ok, min_y0 <= max_y0, $id('starty2'), "Max y must not be less than min y");
		ok = validateField(ok, n_y0 > 0, $id('nstarty'), "Number of values to graph must be one or more");

		if ($id('startdy1').style.display !== 'none') {
			const min_dy0 = Number($id('startdy1').value);
			const max_dy0 = Number($id('startdy2').value);
			const n_dy0 = Number($id('nstartdy').value);

			ok = validateField(ok, min_dy0 <= max_dy0, $id('startdy1'), "Min y' must not be greater than max y'");
			ok = validateField(ok, min_dy0 <= max_dy0, $id('startdy2'), "Max y' must not be less than min y'");
			ok = validateField(ok, n_dy0 > 0, $id('nstartdy'), "Number of values to graph must be one or more");
		}

		if ($id('startz1').style.display !== 'none') {
			const min_z0 = Number($id('startz1').value);
			const max_z0 = Number($id('startz2').value);
			const n_z0 = Number($id('nstartz').value);

			ok = validateField(ok, min_z0 <= max_z0, $id('startz1'), "Min z must not be greater than max z");
			ok = validateField(ok, min_z0 <= max_z0, $id('startz2'), "Max z must not be less than min z");
			ok = validateField(ok, n_z0 > 0, $id('nstartz'), "Number of values to graph must be one or more");
		}

		return ok;
	}

	function redraw() {
		if (!validate())
			return;
		if (/^\s*$/.test($id('exp1').value))
			return;

		const timeStep = Number($id('timestep').value);
		const startTime = Number($id('starttime').value);
		const endTime = Number($id('endtime').value);
		const t0 = Number($id('t0').value);

		let [ok, result] = tokenize($id('exp1').value);
		if (!ok) {
			highlightParseError($id('exp1'), result);
			return;
		}
		[ok, result] = parse(result);
		if (!ok) {
			highlightParseError($id('exp1'), result);
			return;
		}
		const fn = compileFunction(result);

		const min_y0 = Number($id('starty1').value);
		const max_y0 = Number($id('starty2').value);
		const n_y0 = Number($id('nstarty').value);
		const y0_values = gradations(min_y0, max_y0, n_y0);

		const hueScale = d3.scaleLinear().domain([min_y0, max_y0]).range([0,270]);

		let solutions, colors, satScale, lightScale;
		switch($id('graphtype').value) {
		case 'order1':
			solutions = order1_solutions(y0_values, t0, startTime, endTime, timeStep, fn);
			colors = solutions.map((solution) => d3.hsl(hueScale(solution.startY), 0.75, 0.75).formatHex());
			vp1.draw(solutions.map((s) => new DerivativeLine(s, 0, fn)), colors);
			vp2.draw(solutions.map((s) => new TimeLine(s)), colors);
			break;

		case 'order2':
			const min_dy0 = Number($id('startdy1').value);
			const max_dy0 = Number($id('startdy2').value);
			const n_dy0 = Number($id('nstartdy').value);
			const dy0_values = gradations(min_dy0, max_dy0, n_dy0);
			solutions = order2_solutions(y0_values, dy0_values, t0, startTime, endTime, timeStep, fn);
			satScale = d3.scaleLinear().domain([min_dy0, max_dy0]).range([0.34,0.84]);
			lightScale = d3.scaleLinear().domain([min_dy0, max_dy0]).range([0.78,0.48]);
			colors = solutions.map((solution) => d3.hsl(hueScale(solution.startY), satScale(solution.startZ), lightScale(solution.startZ)).formatHex());
			vp1.draw(solutions.map((s) => new PhaseLine(s)), colors);
			vp2.draw(solutions.map((s) => new TimeLine(s)), colors);
			break;

		case 'eqs2_order1':
			if (/^\s*$/.test($id('exp2').value))
				return;
			const min_z0 = Number($id('startz1').value);
			const max_z0 = Number($id('startz2').value);
			const n_z0 = Number($id('nstartz').value);
			const z0_values = gradations(min_z0, max_z0, n_z0);
			[ok, result] = tokenize($id('exp2').value);
			if (!ok) {
				highlightParseError($id('exp2'), result);
				return;
			}
			[ok, result] = parse(result);
			if (!ok) {
				highlightParseError($id('exp2'), result);
				return;
			}
			const fn2 = compileFunction(result);
			solutions = eqs2_order1_solutions(y0_values, z0_values, t0, startTime, endTime, timeStep, fn, fn2);
			satScale = d3.scaleLinear().domain([min_z0, max_z0]).range([0.34,0.84]);
			lightScale = d3.scaleLinear().domain([min_z0, max_z0]).range([0.78,0.48]);
			colors = solutions.map((solution) => d3.hsl(hueScale(solution.startY), satScale(solution.startZ), lightScale(solution.startZ)).formatHex());
			switch($id('graph1').value) {
				case 'z-y': vp1.draw(solutions.map((s) => new PhaseLine(s)), colors); break;
				case 'dy-y': vp1.draw(solutions.map((s) => new DerivativeLine(s, 0, fn)), colors); break;
				case 'y-t': vp1.draw(solutions.map((s) => new TimeLine(s)), colors); break;
				case 'dz-z': vp1.draw(solutions.map((s) => new DerivativeLine(s, 1, fn2)), colors); break;
				case 'z-t': vp1.draw(solutions.map((s) => new TimeLine(s, 1)), colors); break;
			}
			switch($id('graph2').value) {
				case 'z-y': vp2.draw(solutions.map((s) => new PhaseLine(s)), colors); break;
				case 'dy-y': vp2.draw(solutions.map((s) => new DerivativeLine(s, 0, fn)), colors); break;
				case 'y-t': vp2.draw(solutions.map((s) => new TimeLine(s)), colors); break;
				case 'dz-z': vp2.draw(solutions.map((s) => new DerivativeLine(s, 1, fn2)), colors); break;
				case 'z-t': vp2.draw(solutions.map((s) => new TimeLine(s, 1)), colors); break;
			}
			break;
		}
	}

	$id('graphtype').listen('change', (event) => {
		if (event.target.value === 'eqs2_order1') {
			for (const elem of $class('eqs2only')) elem.style.display = '';
			vp1.setTitles(...axisTitles[$id('graph1').value]);
			vp2.setTitles(...axisTitles[$id('graph2').value]);
		} else {
			for (const elem of $class('eqs2only')) elem.style.display = 'none';
			vp1.setTitles('y', "y'");
			vp2.setTitles('t', 'y');
		}

		for (const elem of $class('order2only'))
			elem.style.display = (event.target.value === 'order2') ? '' : 'none';
		$id('exp1').labels[0].textContent = (event.target.value === 'order2') ? "y'' =" : "y' =";

		redraw();
	});

	$id('exp1').listen('change', redraw);
	$id('exp2').listen('change', redraw);
	$id('exp1').listen('keydown', () => clearParseError($id('exp1')));
	$id('exp2').listen('keydown', () => clearParseError($id('exp2')));

	$id('timestep').listen('change', redraw);
	$id('starttime').listen('change', redraw);
	$id('endtime').listen('change', redraw);

	$id('t0').listen('change', (event) => {
		$id('starty1').labels[0].textContent = `Min. y(${event.target.value}):`;
		$id('starty2').labels[0].textContent = `Max. y(${event.target.value}):`;
		$id('startdy1').labels[0].textContent = `Min. y'(${event.target.value}):`;
		$id('startdy2').labels[0].textContent = `Max. y'(${event.target.value}):`;
		$id('startz1').labels[0].textContent = `Min. z(${event.target.value}):`;
		$id('startz2').labels[0].textContent = `Max. z(${event.target.value}):`;
		redraw();
	});

	$id('starty1').listen('change', redraw);
	$id('starty2').listen('change', redraw);
	$id('nstarty').listen('change', redraw);
	$id('startdy1').listen('change', redraw);
	$id('startdy2').listen('change', redraw);
	$id('nstartdy').listen('change', redraw);
	$id('startz1').listen('change', redraw);
	$id('startz2').listen('change', redraw);
	$id('nstartz').listen('change', redraw);

	$id('graph1').listen('change', (event) => {
		vp1.setTitles(...axisTitles[event.target.value]);
		redraw();
	});
	$id('graph2').listen('change', (event) => {
		vp2.setTitles(...axisTitles[event.target.value]);
		redraw();
	});

	$id('sample_Y').listen('click', () => {
		$id('graphtype').value = 'order1';
		$id('exp1').value = 'y';
		$id('starttime').value = '0';
		$id('endtime').value = '5';
		$id('timestep').value = '0.01';
		$id('t0').value = '0';
		$id('starty1').value = '-3';
		$id('starty2').value = '3';
		$id('nstarty').value = '5';
		fireEvent($id('graphtype'), 'change');
	});
	$id('sample_cosY').listen('click', () => {
		$id('graphtype').value = 'order1';
		$id('exp1').value = 'cos(y)';
		$id('starttime').value = '0';
		$id('endtime').value = '10';
		$id('timestep').value = '0.01';
		$id('t0').value = '0';
		$id('starty1').value = '-1';
		$id('starty2').value = '10.5';
		$id('nstarty').value = '30';
		fireEvent($id('graphtype'), 'change');
	});
	$id('sample_riccati').listen('click', () => {
		$id('graphtype').value = 'order1';
		$id('exp1').value = '-((y^2) * (t^2)) + ((2 * y) / t)';
		$id('starttime').value = '1';
		$id('endtime').value = '3.5';
		$id('timestep').value = '0.01';
		$id('t0').value = '1';
		$id('starty1').value = '1.5';
		$id('starty2').value = '3.5';
		$id('nstarty').value = '8';
		fireEvent($id('graphtype'), 'change');
	});
	$id('sample_logistic').listen('click', () => {
		$id('graphtype').value = 'order1';
		$id('exp1').value = '(10*y)-(y^2)';
		$id('starttime').value = '-1';
		$id('endtime').value = '1';
		$id('timestep').value = '0.01';
		$id('t0').value = '0';
		$id('starty1').value = '1';
		$id('starty2').value = '5';
		$id('nstarty').value = '10';
		fireEvent($id('graphtype'), 'change');
	});
	$id('sample_cosT').listen('click', () => {
		$id('graphtype').value = 'order2';
		$id('exp1').value = 'cos(t)';
		$id('starttime').value = '-10';
		$id('endtime').value = '10';
		$id('timestep').value = '0.05';
		$id('t0').value = '0';
		$id('starty1').value = '-3';
		$id('starty2').value = '3';
		$id('nstarty').value = '5';
		$id('startdy1').value = '-3';
		$id('startdy2').value = '3';
		$id('nstartdy').value = '5';
		fireEvent($id('graphtype'), 'change');
	});
	$id('sample_cosY_2').listen('click', () => {
		$id('graphtype').value = 'order2';
		$id('exp1').value = 'cos(y)';
		$id('starttime').value = '-10';
		$id('endtime').value = '10';
		$id('timestep').value = '0.02';
		$id('t0').value = '0';
		$id('starty1').value = '-3';
		$id('starty2').value = '3';
		$id('nstarty').value = '5';
		$id('startdy1').value = '-3';
		$id('startdy2').value = '3';
		$id('nstartdy').value = '5';
		fireEvent($id('graphtype'), 'change');
	});
	$id('sample_mathieu').listen('click', () => {
		$id('graphtype').value = 'order2';
		$id('exp1').value = '(1 + (2 * cos(t))) * y';
		$id('starttime').value = '-12.5';
		$id('endtime').value = '12.5';
		$id('timestep').value = '0.05';
		$id('t0').value = '0';
		$id('starty1').value = '-5';
		$id('starty2').value = '5';
		$id('nstarty').value = '4';
		$id('startdy1').value = '-3';
		$id('startdy2').value = '3';
		$id('nstartdy').value = '4';
		fireEvent($id('graphtype'), 'change');
	});
	$id('sample_cauchy').listen('click', () => {
		$id('graphtype').value = 'order2';
		$id('exp1').value = "((-2.75 / t) * y') + ((-4.8 / (t^2)) * y)";
		$id('starttime').value = '2';
		$id('endtime').value = '35';
		$id('timestep').value = '0.05';
		$id('t0').value = '2';
		$id('starty1').value = '-1.5';
		$id('starty2').value = '1.5';
		$id('nstarty').value = '4';
		$id('startdy1').value = '-2';
		$id('startdy2').value = '2';
		$id('nstartdy').value = '3';
		fireEvent($id('graphtype'), 'change');
	});
	$id('sample_meissner').listen('click', () => {
		$id('graphtype').value = 'order2';
		$id('exp1').value = "-y*(2 + (3 * sgn(cos(t))))";
		$id('starttime').value = '-10';
		$id('endtime').value = '10';
		$id('timestep').value = '0.01';
		$id('t0').value = '0';
		$id('starty1').value = '-3';
		$id('starty2').value = '3';
		$id('nstarty').value = '5';
		$id('startdy1').value = '-3';
		$id('startdy2').value = '3';
		$id('nstartdy').value = '5';
		fireEvent($id('graphtype'), 'change');
	});
	$id('sample_predprey').listen('click', () => {
		$id('graphtype').value = 'eqs2_order1';
		$id('exp1').value = 'y-(0.01*y*z)';
		$id('exp2').value = '-z+(0.02*y*z)'
		$id('starttime').value = '0';
		$id('endtime').value = '20';
		$id('timestep').value = '0.05';
		$id('t0').value = '0';
		$id('starty1').value = '10';
		$id('starty2').value = '20';
		$id('nstarty').value = '3';
		$id('startz1').value = '10';
		$id('startz2').value = '20';
		$id('nstartz').value = '3';
		fireEvent($id('graphtype'), 'change');
	});

	redraw();
</script>

<hr>

<p>Classic Runge-Kutta, also known as “RK4”, generates four different estimates of the rate of change of each variable at each time step, and takes a weighted sum of those four estimates as a final estimate which is (usually) more accurate than any of the four. Then, we use those estimated derivatives to adjust the values of each variable, bump “time” forward by one step, and repeat until we reach the ending time of the simulation. Here is a simple implementation of RK4 for a system with just one dependent variable:</p>

{% highlight javascript %}
// Trace out evolution of our system using classic Runge-Kutta (AKA "RK4")
// Store results in a packed array of floats
function rk4trace(y, t, Δt, fn, array, i, Δi, limit) {
  while (i !== limit) {
    const half_Δt = Δt / 2.0;
    const next_t = t + Δt;
    const half_t = t + half_Δt;

    const k_1 = fn(t, y); // Slope at starting point
    const k_2 = fn(half_t, y + (half_Δt * k_1)); // Estimated slope at mid-point
    const k_3 = fn(half_t, y + (half_Δt * k_2)); // Another estimate of slope at mid-point
    const k_4 = fn(next_t, y + (Δt * k_3)); // Estimated slope at endpoint

    const slope = (k_1 + 2*k_2 + 2*k_3 + k_4) / 6.0; // Weighted average of those four slopes

    y += Δt * slope;
    array[i] = y;
    t += Δt;
    i += Δi;
  }
}

// Apply RK4 to find phase lines for a system with one dependent variable
function rk4solve(y_0, t_0, t_start, t_end, Δt, fn) {
  const timeSteps = Math.floor(((t_end - t_start) / Δt) + 1);
  // Packed array of variable values at each time step:
  const array = new Float64Array(timeSteps);

  let t = t_0, y = y_0, i = Math.floor((t_0 - t_start) / Δt);
  array[i] = y_0;

  // Trace out phase line from starting point
  rk4trace(y_0, t_0, Δt, fn, array, i+1, 1, array.length);

  // Trace out phase line in the opposite direction from the starting point
  rk4trace(y_0, t_0, -Δt, fn, array, i-1, -1, -1);

  return array;
}
{% endhighlight %}

<p>The above implementation stores the values of the dependent variable in a <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array'><code>Float64Array</code></a> instead of a regular JavaScript Array; this is for speed and memory efficiency. It doesn't store the time value for each entry in the array, since that can be easily rederived from <code>t_start</code>, <code>t_end</code>, and <code>Δt</code>.</p>

<hr>

<h2 id='syntax'>Expression Syntax Help for this Tool</h2>

<table>
	<tr><td>Variables</td><td><code>t</code> <code>y</code><br><code>y'</code> <i>(for 2<sup>nd</sup>-order equations)</i><br><code>z</code> <i>(for systems of two 1<sup>st</sup>-order equations)</i><br><code>x</code> <i>(alternative name for <code>t</code>)</i></td></tr>
	<tr>
		<td>Numbers</td>
		<td>
			<code>1</code>, <code>2</code>, <code>-1</code>, etc<br>
			<code>1.1234</code>...<br>
			<code>e</code> <i>(Euler's number, 2.71828...)</i><br>
			<code>pi</code> or <code>π</code> <i>(3.14159...)</i><br>
			If you want any other mathematical constants, drop the author a line.
		</td>
	</tr>
	<tr><td>Arithmetic</td><td><code><i>expression</i> + <i>expression</i></code><br>Other binary operators are <code>-</code>, <code>*</code>, <code>/</code>, and <code>^</code> or <code>**</code> for exponentiation<br><code>-<i>expression</i></code> for negation</td></tr>
	<tr><td>Parentheses</td><td><code>(<i>expression</i>)</code><br>Use parentheses to ensure expressions are grouped in the way you want</td></tr>
	<tr>
		<td>Functions</td>
		<td>
			<code>sqrt(<i>expression</i>)</code><br>
			<code>sin(<i>expression</i>)</code> <i>(for trig functions, the input parameter is in radians)</i><br>
			<code>cos(<i>expression</i>)</code><br>
			<code>tan(<i>expression</i>)</code><br>
			<code>arcsin(<i>expression</i>)</code> <i>(inverse trig functions)</i><br>
			<code>arccos(<i>expression</i>)</code><br>
			<code>arctan(<i>expression</i>)</code><br>
			<code>ln(<i>expression</i>)</code> or <code>log(<i>expression</i>)</code> <i>(natural logarithm)</i><br>
			<code>log10(<i>expression</i>)</code><br>
			<code>log2(<i>expression</i>)</code><br>
			<code>sign(<i>expression</i>)</code> or <code>sgn(<i>expression</i>)</code> <i>(0 for zero, 1 for positive numbers, -1 for negative numbers)</i><br>
			If you want any other mathematical functions, drop the author a line.
		</td>
	</tr>
</table>

<p><i><b>Special thanks</b> to Gilbert Strang for his text “Differential Equations and Linear Algebra”, which inspired me to make this tool.</i></p>
